The use of increasing levels of parallelism and concurrency in HPC and Cloud is a double-edged sword: while it helps increase performance, save energy, and enhance user experience, it
unfortunately comes with the cost of concurrency bugs.
%
This trend can worsen with the upcoming HPC/Cloud
integration~\cite{dan-herbein-dong} unless we accelerate the
development of concurrency debugging methods.
%
However, unless these debugging systems themselves are
simple and widely applicable, the maintenance of multiple debugging and testing approaches will also prove to be a burden.
%
Driven by these observations, in this paper, we take a feature-rich language, namely Go~\cite{go}, research how to develop a practical analysis (\ie~testing and debugging) method for real-world Go programs, and present the resulting new tool called \goat.
%
The main contribution of this work is to demonstrate how
\goat's static and dynamic analysis methods---while very well known
by their names and effectiveness in simpler contexts---can
be brought to bear on realistic bug scenarios in the setting of
a complex language such as Go.

Go~\cite{go} is a statically typed language initially developed by Google.
%
It employs channel-based Hoare's Communicating Sequential Processes (CSP)~\cite{hoare-csp78} semantics in its core and provides a productivity-enhancing environment for concurrent programming.
%
Go enjoys accelerating acceptance in a wide variety of
communities including container software systems~\cite{merkel2014docker,kubernetes},  distributed key-value databases~\cite{etcd,cockroachdb-sigmod20}, and web server libraries \cite{grpc}.
%
It involves shared memory, message passing, non-deterministic message reception and selection, dynamic process creation, and programming styles that tend to create thousands of \textit{goroutines}~(\ie~application-level threads) and discard them to be garbage collected when not needed.
%
The combination of these features is well known for Go's popularity, yet they also make Go challenging to debug.
%
Our work is especially relevant considering that there are no widely practical tools for debugging concurrent Go; even well-curated
concurrency bug benchmark suites are only just now beginning to appear~\cite{tu-concurrentBugs-asplos19,yuan-gobench-cgo21}.
%

In general, concurrent bugs are notoriously difficult to find and reproduce due to the non-deterministic choices that the scheduler makes during execution.
%
In Go, constructs like \textit{select} and buffered channels entangle the process of debugging by introducing extra randomness to the dynamic behavior of the program.
%
Recent static~\cite{ng-dl-cc16,stadtmuller-minigo-aplas16,lange-fence-popl17,lange-staticType-icse18} and dynamic~\cite{go-race-blog,zhao-occam97,sulzmann-corr17,sulzmann-twophase-2018,dilley-gomela-corr2020} techniques have been proposed to address these challenges.
%
Although static methods are proved to be rigorously effective in detecting flaws in small programs, they often produce false positives and suffer from state explosion problems for realistic programs.
%
On the other hand, dynamic analysis approaches cover a more significant subset of real-world programs by constructing and analyzing an \textit{execution model}.
%
However, for large codebases with thousands of LOC, it is non-trivial to capture an accurate dynamic execution model using source instrumentation or source-to-source translation.
%
In addition, our experiments (section \ref{sec:f} **FIXME**) and results in~\cite{yuan-gobench-cgo21} show that some buggy programs takes up to more than 1000 runs to manifest the bug.
%
Concurrent testing methods~\cite{arora-concrrentTesting-16} are proposed to complement static and dynamic approaches in tackling challenges of concurrent debugging.
%
To the best of our knowledge, there exist no such testing methods applicable to Go semantics.
%
We implemented \goat, an analysis and testing framework for concurrent Go applications to address this lack.
%
\goat combines static and dynamic approaches to automatically analyze the behavior of concurrent components and facilitate testing and debugging Go applications.
%
Several classic ideas from literature are combined with novel ones to support modern concepts of Go in /goat, which pursues three primary objectives:
\\
\noindent{\bf Objective 1:\/} \textit{Accurate Dynamic Execution Modeling}---
To study the behavior of concurrent components and track the program's state during executions, a dynamic execution model has to construct to get compared against a pre-defined model (\eg formally defined specification or developer's mental model of the program).
%
It is crucial for debuggers and software analysis tools to construct their execution models as close as possible to the actual program execution context.
%
Since a bug might occur at various levels of abstraction, \textit{dynamic tracing} provides a practical and uniform way to track multiple facets of the program during execution (as we have shown in our priorwork~\cite{difftrace}).
%
We have enhanced the built-in tracing mechanism of Go~\cite{ect-arxiv} to capture the dynamic behavior of concurrency primitives in the form of a sequence of events (execution concurrency trace---ECT).
%
Each event in ECT represents an action that corresponds to exactly one statement in the source code.
%
The ECT provides an accurate model of how a program behaves dynamically and assists debugging procedures (\eg bug detection, root-cause analysis, execution visualization).
%
Our experiments show that \goat detects all blocking bugs of GoKer~\cite{yuan-gobench-cgo21} many of which are overlooked or unnoticed by existing debugging tools by replaying the program's ECT.
\\
\noindent{\bf Objective 2:\/} \textit{Systematic Exploration of Schedule-Space}---
Since the scheduler's non-deterministic behavior is the primary reason for Heisenbugs (\ie errors that are uncommon to occur and hard to reproduce), these bugs may not manifest during conventional testing.
%
By adopting ideas from \textit{systematic concurrency testing} approaches~\cite{dpor,thomson-concurrencyTesting-ppopp14,emmi-delayBounded-popl11,burckhardt-depthBug-asplos10,madanlal-preemptionBound-pldi07,yu-maple-oopsla12,joshi-calfuzzer,contest-jgi01,edelstein2003contest,hong-syncTesting-issta12,christakis-erlang-icst13,yuan-morpheus-asplos20}, we perturb the native scheduler of Go to explore the unconventional but feasible execution interleaving.
%
First, we statically identify the source location of concurrency primitive usages in a given program as their behavior defines the program's dynamic behavior.
%
Then we inject \goat handlers around these locations to manage schedule perturbation.
%
At its simplest form, handlers randomly decide if the current goroutine should continue executing or \textit{yield} to other goroutines to execute first.
%
Such yields change the blocking behavior of the program within the space of feasible states and exercise untested interleavings, consequently heighten the propensity for bug introduction.
%
Our experiments show that it is effective in accelerating the exposure of rare bugs.

\noindent{\bf Objective 3:\/} \textit{Testing Quality Measurement}---
The effectiveness of software testing is often assessed by measuring coverage of some aspects of the software, such as its source-code statements (\eg higher statement coverage of a test suite shows its higher thoroughness).
%
In the context of conrruent software, exisiting coverage metrics~\cite{edelstein2003contest,trainin-followsCoverage-padtad09,hong-syncTesting-issta12,yu-pset-isca09} characterize (quantify) the behavior of concurrency primitives which enables the quality measurement of schedule-space exploration.
%
The characterization process consists of defining a set of requirements that must be met during testing and a method for measuring whether those requirements are met.
%
Since Go combines traditional synchronization and serialization primitives~(mutex, conditional variables) with message-passing and introduces new concepts such as \textit{select-case}~(non-deterministic communication and synchronization), new coverage requirements are required to characterize the behavior of Go concurrency.
%
Using the \goat's infrastructure, we deep studied the underlying causes of bugs in GoKer benchmark~\cite{yuan-gobench-cgo21} and proposed a set of coverage requirements that 1) coherently characterize the dynamic behavior of concurrency primitives under various scheduling scenarios, and 2) enable measurement of schedule-space exploration until reaching a threshold, or the bug is exposed.
%
We identify if coverage requirements are covered during testing by analyzing the test's ECT.
%
We demonstrate that our novel coverage metric is effective in measuring the schedule-space exploration progress.


To summarize, here are our main contributions:
\begin{itemize}
    \item We introduce \goat, a testing and analysis framework that facilitates whole-program trace collection (via an enhancement to the standard tracer package) and knowledge discovery about the program's dynamic behavior.
    \item We automatically identify concurrency usage of given programs and inject handlers around them to systematically explore the interleaving space and accelerate bug manifestation.
    \item We propose a set of coverage requirements that characterize the dynamic behavior of concurrency primitives, enabling measurement of quality and progress of schedule-space exploration.
\end{itemize}

\stcmtside{need to update}
The rest of this paper is as follows: Section \ref{sec:correctness} discusses correctness problems and approaches in Go. Section \ref{sec:ect} describes the enhancement we made to the tracer package. Section \ref{sec:disc} discusses the advantages of dynamic tracing for concurrent debugging and draws the ongoing and future direction of the current work. At last, section \ref{sec:summary} summarizes and concludes.
